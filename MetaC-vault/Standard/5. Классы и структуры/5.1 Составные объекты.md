В MetaC структуры отличаются от классов и от буферов.

Типы объединённых данных в MetaC:
1) `struct`
2) `class`
3) `interface`
4) `buffer`
5) `union`

### struct
Структуры по умолчанию это Plain Old Data (POD). Т.е. имеют только
поля, которые можно безопасно копировать, присваивать и прочее.
Структуры это просто данные.
Структуры обычно выделяются на стеке.

### class
Классы это объекты со сложной логикой.
Классы обычно выделяются на куче.

### interface
Это классы не имеющие отдельных определённых членов.
Интерфейсы показывают какой функционал должен быть у класса.
От интерфейса можно наследовать.

### buffer
Буферы это структуры с некоторыми необычными свойствами.
Буферы это POD но выделяются на куче при большом объёме 
и на стеке при не большом. Буферы могут лениво копироваться.
Если структура или класс содержит буфер-член то при копировании
этого класса или структуры буфер будет доступен для обоих
этих объектов по одному указателю.
Копирование буфера произойдёт только если структура или класс попытаются
записать данные в буфер (или это будет сделано явно).
Также отличительной особенностью является более безопасная
работа с памятью буфера.

### union
Объекты этого типа позволяют хранить одно из объявленных
в его полях значений. Мы также можем узнать значение какого типа
сейчас используется.
Мы также можем переключать тип этого значения.

### Вложенные объявления
Можно вкладывать в объекты другие объекты.
Если мы возвращаем из метода объект вложенного типа
переменную под него можно создать при условии, что
инициализация будет происходить через присвоение 
### Анонимные объекты
Вы можете создать анонимный тип данных для использования в одном 
единственном месте программы.
По функционалу это будет то же самое что и именованные данные,
но объявление будет иным. Доступ к членам будет как обычно.
```
struct StructWithAnonType 
{
    let field : struct {let a : int; let b : float};
}

let testObject : StructWithAnonType;
testObject.field.a = 10;
testObject.field.b = 15.3;

println!(testObject.field.a);
println!(testObject.field.b);
```

Вы можете брать тип от члена-анонимного объекта и создавать копию.
```
let const AnonStruct : struct {};
let const typeOfAnonStruct : type = type(AnonStruct);
let mut AnonStructCopy : typeOfAnonStruct;
AnonStructCopy.a = 10;
AnonStructCopy.b = 15.3;

println!(AnonStructCopy.a);
println!(AnonStructCopy.b);
// 10 15.3
```
### Доступ классы/структуры
Есть 3 уровня доступа к членам:
1. `public` - члены доступные извне и изнутри, в дочерних классах
2. `private` - члены доступные только изнутри, в дочерних классах (protected c++)
3. `own` - члены доступны только изнутри. (private c++)

По умолчанию используется public.

### Выбор перегрузки
В отличие от c++ мы можем перегружать методы, которые отличаются
приватностью.