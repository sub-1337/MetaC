Функции получают внутрь параметры.

```
fn function(let const x, let mut y, let copy z, let const copy k)
{

}
```

Параметр `x` передаётся константой  его нельзя изменить.
Параметр `y` передаётся по ссылке его можно поменять - изменится
переменная и вовне. 
Параметр `z` передаётся копией - он может быть изменён, точнее
его копия, оригинальная переменная не изменится.
Параметр `k` передаётся копией, которую нельзя изменить.

Вот сравнение параметров функций MetaC с c++.

| c++           | MetaC            |
| ------------- | ---------------- |
| const auto& x | let const x      |
| auto& y       | let mut y        |
| auto z        | let copy z       |
| const auto k  | let const copy k |

`...(let i)`
Если не указывать тип - он будет выведен автоматически.

### Возвращаемые значения
```
fn returnName() -> (let : string)
{
	return "Joe";
}
```
Вернёт копию (значение), по дефолту.

```
fn returnName() -> (let copy : string)
{
	return "Joe";
}
```
Вернёт копию (значение).

```
fn createArray() -> (let ref : int[])
{
	let mut arrayToReturn : int[];
	return arrayToReturn;
}
```

### Возвращение нескольких переменных
```
fn retMult() -> (let copy : int, let copy : string)
{
	return (5, "Test");
}

let const (numName, stringName) = retMult();
(let mut numName, len const stringName) = retMult();
```
### Значения по умолчанию
Можно задавать значения по умолчанию у функций.
`void` спец слово чтобы явно использовать умолчательный параметр.
```
fn test(let const a = 10, let const b = "Test") { println!("{}{}", a, b); }
test(5, "Lol");           // 5 lol
test(void, "Kek");        // 10 Kek
test(5);                  // 5 Test
test();                   // 10 Test
test(a = 30, b = "Heh");  // 30 Heh
test(b = "Heh", a = 30);  // 30 Heh
```

### Безымянные параметры
```
fn test(let : int, let : string)
{
	println!(@::0, @::1);
}

test(10, " hello"); // Напечатает 10 hello
```