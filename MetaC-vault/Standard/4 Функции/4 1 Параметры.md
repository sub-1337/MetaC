Функции получают внутрь параметры.

```
fn function(let const x, let mut y, let copy z, let const copy k)
{

}
```

Параметр `x` передаётся константой  его нельзя изменить.
Параметр `y` передаётся по ссылке его можно поменять - изменится
переменная и вовне. 
Параметр `z` передаётся копией - он может быть изменён, точнее
его копия, оригинальная переменная не изменится.
Параметр `k` передаётся копией, которую нельзя изменить.

Вот сравнение параметров функций MetaC с c++.

| c++           | MetaC                                   |
| ------------- | --------------------------------------- |
| const auto& x | let const x                             |
| auto& y       | let mut y                               |
| auto z        | let copy z                              |
| const auto k  | let const copy k // возможно бесполезно |

`...(let i)`
Если не указывать тип - он будет выведен автоматически.

### Возвращаемые значения
```
fn returnName() -> (let : string)
{
	return "Joe";
}
```
Вернёт копию (значение), по дефолту.

```
fn returnName() -> (let copy : string)
{
	return "Joe";
}
```
Вернёт копию (значение).

```
fn createArray() -> (let ref : int[])
{
	let mut arrayToReturn : int[];
	return arrayToReturn;
}
```

### Возвращение нескольких переменных
```
fn retMult() -> (let copy : int, let copy : string)
{
	return (5, "Test");
}

let const (numName, stringName) = retMult();
(let mut numName, len const stringName) = retMult();
```
### Значения по умолчанию
Можно задавать значения по умолчанию у функций.
`void` спец слово чтобы явно использовать умолчательный параметр.
```
fn test(let const a = 10, let const b = "Test") { println!("{}{}", a, b); }
test(5, "Lol");           // 5 lol
test(void, "Kek");        // 10 Kek
test(5);                  // 5 Test
test();                   // 10 Test
test(a = 30, b = "Heh");  // 30 Heh
test(b = "Heh", a = 30);  // 30 Heh
```

### Безымянные параметры
```
fn test(let : int, let : string)
{
	println!(@::0, @::1);
}

test(10, " hello"); // Напечатает 10 hello
```

### nodiscard
Спецификатор `nodiscard` говорит что мы не можем проигнорировать возврат функции.
```
fn nodiscard func() -> let : int
{
	return 10;
}

let a : int = func(); // Ok
ignore func(); // Ok
func(); // Error
```

### специальные параметры (множественые)
Мы можем определить переменное количество параметров.

#### Статичные
```
import args;
#fn func(#let args : args[...])
{
	#foreach(#let param : args)
	{
		println!(param);
	}
}

func(1, 3.14, "hello"); // 1 3.14 hello
```

#### Динамические
```
import args::dynamic;
@fn func(@let args : [@...])
{
	@foreach(@let param : args::dynamic)
	{
		println!(param);
	}
}

func(1, 3.14, "hello"); 1 3.14 hello
```
  В таком случае функция будет работать медленнее (возможно в разы)
  но сможет в рантайме обрабатывать разные типы. 